# Matrix
Набор классов, позволяющий решать системы линейных уравнений в матричном виде с помощью метода Гаусса. В качестве стандартного типа для решения матриц используется [Large](https://github.com/Irval1337/LongArithmetic). Соответственно, решение СЛУ размера больше 20 будет выполняться достаточно долго, а дробные коэффициенты не поддерживаются в принципе.

## Функционал класса `Matrix<T>`
* Конструкторы из `std::vector<std::vector<T>>` и `std::initializer_list<std::initializer_list<T>>` (каждая строка дополняется нулями, если матрица не прямоугольная);
* Конструктор из `Matrix<U>`. Для конветрации каждого элемента используется `static_cast<T>`;
* Конструктор, задающий только количество строк и столбцов;
* Конструкторы и операторы присваивания для lvalue reference и rvalue reference (move семантика);
* Оператор `(i, j)` для получения доступа к элементу матрицы в i-ой строке, j-ом столбце;
* Геттеты `rows()` и `columns()`;
* Все логические операторы;
* Операторы `+`, `-`, `*` (скаляр и матрица), `/` (скаляр справа) и производные от них присваивания;
* Функция `Trace()`, вычисляющая след;
* Функция `Transposed()`, возращающая транспонированный вид матрицы;
* Функции `ForEach(std::function<void(size_t, size_t, T&)> func)`, `ForRow(size_t row, std::function<void(size_t, T&)> func)` и `ForColumn(size_t col, std::function<void(size_t, T&)> func)`, применяющие указанный функтор к каждому элементу в матрице/столбце/строке. В качестве аргументов функтору передаются положение текущего элемента в матрице/столбце/строке и lvalue reference на этот элемент. Каждая из этих функций возращает `*this` в качестве результата;
* Friend-функции `swap(Matrix<U>&, Matrix<U>&)`, `std::ostream& operator<<(std::ostream&, const Matrix<U>&)` и `pow(const Matrix<V>&, const U&)` (изначально используется алгоритм бинарного возведения в степень).


## Функционал класса `LinearEquationSystem`
* Класс является производным от `Matrix<Large>`, следовательно, перенимает все его свойства. В качестве внутренней матрицы хранится матрица коэффициентов с приписанным к ней справа столбцом свободных коэффициентов;
* Функция `GetRatio()`, возвращающая матрицу коэффициентов;
* Функция `GetColumn()`, возвращающая столбец свободных коэффициентов;
* Функция `Solve()`, применяющая алгоритм Гаусса к СЛУ. Асимптотика работы $O(n^3)$, если считать, что матрица не вырожденная.
* Функция `GetSolutions()`, которая возвращает вектор всех решений СЛУ. Каждое решение является экземпляром `LinearSolution`.
* Незначительно изменена friend-функция `std::ostream& operator<<(std::ostream&, const LinearEquationSystem<U>&)`.


## Встроенный пример реализации
В файле `main.cpp` представлен пример использования описанных классов с целью решения СЛУ, вводимых пользователем из стандартного потока. В первой строке необходимо ввести число `n` - количество строк и переменных в матрице. Далее ожидается ввод `n` строк по `n+1` целых чисел. Результатом работы программы будет вывод матрицы в улучшенном ступенчатом виде, а также общего решения СЛУ (если оно есть).

### Пример работы
*Input*
```
4
-4 3 -3 5 9
6 0 -18 6 -18
-8 6 -6 10 18
1 -4 17 -11 1
```
*Output*
```
 1  0 -3  1 | -3
 0  1 -5  3 | -1
 0  0  0  0 |  0
 0  0  0  0 |  0

x_1 = 3*x_3 - x_4 - 3
x_2 = 5*x_3 - 3*x_4 - 1
```

## Сборка
В проекте используется кроссплатформенная система мета-сборки [CMake](https://cmake.org/). Обязательна компиляция с помощью clang++ или g++. Для быстрого начала работы с репозиторием используйте:
```
git clone https://github.com/Irval1337/Matrix.git
cd Matrix
cmake .
cmake --build .
```

## Создание Pull request
1. Сделайте fork проекта
2. Создайте ветку со своим изменением (git checkout -b feature/AmazingFeature)
3. Сделайте commit своих изменений (git commit -m 'Add some AmazingFeature')
4. Сделайте push в основную ветку (git push origin feature/AmazingFeature)
5. Откройте pull request на GitHub
